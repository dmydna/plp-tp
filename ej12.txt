{CONMUT} ∀n, m :: Nat · suma n m = suma m n


Demostrar:
 ∀e :: Expr . cantLit e = S (cantOp e)


Por principio de inducción estructural, sea P una propiedad sobre el tipo Expr:
1. Si P vale sobre Const.
2. Si P vale sobre Rango.
3. Si P vale sobre Suma.
4. Si P vale sobre Resta.
5. si P vale sobre Mult.
6. si P vale sobre Div.
Entonces, ∀e :: Expre. P(e)

En esta demostración, P(e) := ∀e :: Expr . cantLit e = S (cantOp e)

Casos base

Caso 1. e = Const n

∀n :: Float . ∀e :: Expr. e = (Const n):

       cantLit (Const n) 
{L1} = S Z 
{O1} = S (cantOp (Const n))

Caso 2. e = Rango n m

∀n,m :: Float . ∀e :: Expr . e = (Rango n m)

       cantLit (Rango n m)
{L2} = S Z
{O2} = S (cantOp (Rang n m))


Casos recursivos

Caso 3. e = Suma e1 e2
con P(e) := ∀e :: Expr . cantLit e = S (cantOp e)  
       TI := P(Suma e1 e2) := ∀e1,e2 :: Expr . cantLit (Suma e1 e2) = S (cantOp (Suma e1 e2)) 
       HI := P(e1) & P(e2) 

                     cantLit e
{L3}     =  suma (cantLit e1) (cantLit e2)
{HI}     =  suma (S (cantOp e1)) (S (cantOp e2))   
{S2}     =  S  (  suma (cantOp e1)  (S (cantOp e2)) )
{CONMUT} =  S  (  suma (S (cantOp e2)) (cantOp e1)  )
{S2}     =  S  (  S (suma (cantOp e2) (cantOp e1)  )) 
{CONMUT} =  S S (suma (cantOp e1) (cantOp e2))
{O3}     =  S cantOp e

Tal y como dice el enunciado, la demostracion para los constructores de Div, Mult y Resta es identica a la de Suma y quedan demostrados con el caso 3.
Con esto queda demostrado que vale P(e) := ∀e :: Expr . cantLit e = S (cantOp e).


